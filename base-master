--master computer
--this program oversees the storage and retrieval of items in the storage system.

--initial configuration defaults
local config = {
	-- base master configuration file
	maxFlightQuantity = {
		item = 64,
		fluid = 1000,
	},
	baseCode = "",
	databasePath = "/basedata",
}

if not os.loadAPI("base") then error("Could not load base API!") end
if not os.loadAPI("flight") then error("Could not load flight API!") end
if not os.loadAPI("configuration") then error("Could not load configuration API!") end
if fs.exists("base.conf") then
	config = configuration.load("base.conf")
else
	--initial setup
	print("Initial Setup for Master Base Controller")
	while not os.getComputerLabel() do
		print("Please provide a label for this computer.")
		write("> ")
		local label = read()
		if #label >= 1 then
			os.setComputerLabel(label)
			break
		else
			print("A label is required!")
		end
	end
	while true do
		print("What is the name code for this base?")
		print("Base name codes are used to group and differentiate sites.")
		write("> ")
		local baseCode = read()
		if baseCode and #baseCode > 0 then
			config.baseCode = baseCode
			break
		else
			print("A base name code is required!")
		end
	end
	configuration.save("base.conf", config)
end

peripheral.find("modem", function(name) rednet.open(name) end)

if os.getComputerLabel() then
	rednet.host("lyq-base", os.getComputerLabel())
else
	print("You must label this computer first.")
	return
end

local stations = {}
local stationInfo = {} --keyed by computer ID.
local surplus = {} --keyed into groups (item, fluid), then by identifier (item name-damage, etc), then by station ID; list of locations.
local request = {} --keyed into groups (item, fluid), then by identifier (item name-damage, etc), then by station ID; list of locations.
local flights = {} --keyed into groups (item, fluid), then by station ID, then numerically-indexed with location, queue, count, and delta keys.
local flightLookup = {}
local flightID = 0 --incremented for each flight, is unique base-wide
local storage = {} --keyed into groups (item, fluid), then by station ID, then by name, then by damage, value is quantity of that object.

local clientProtocol = {
	protocol = "lyq-base",
	name = {station_online = "Station"},
	online = {station_online = true},
	offline = {station_offline = true},
	list = stations,
}

base.initialize(config.baseCode, nil, nil, clientProtocol, true)

local function getDistance(a, b)
	return math.sqrt((b.x - a.x)^2 + (b.y - a.y)^2 + (b.z - a.z)^2)
end

local function areLocationsEqual(a, b)
	return a.x == b.x and a.y == b.y and a.z == b.z
end

local keywords = {
	stations = {
		flightOnly = "flight-base",
		storage = {
			item = "items-inventory",
			fluid = "fluids-inventory",
		},
	},
	capabilities = {
		flight = {
			item = "fly-quad-items",
			fluid = "fly-quad-fluids",
		},
		accept = {
			item = "accept-items",
			fluid = "accept-fluids",
		},
	},
}

local keywordLookup = {}

for class, words in pairs(keywords) do
	keywordLookup[class] = {}
	for word, types in pairs(words) do
		keywordLookup[class][word] = {}
		for obj, name in pairs(types) do
			keywordLookup[class][word][name] = obj
		end
	end
end

local function normalizeName(info)
	if info.name and info.damage then
		return info.name, info.damage
	elseif info.combinedName then
		local name, damage = string.match(info.combinedName, "(.-)%-(%d+)$")
		if name and damage then
			return name, damage
		else
			return info.combinedName, 0
		end
	else
		return false
	end
end

local function resolveObjectName(class, info)
	if class == "item" then
		if info.combinedName then
			return info.combinedName
		elseif info.name and info.damage then
			if info.damage > 0 then
				return info.name.."-"..info.damage
			else
				return info.name
			end
		end
	end
	return false
end

local function getBestBase(obj, id)
	local bases = stationInfo[id].capabilities[keywords.capabilities.flight[obj]]
	if #bases > 1 then
		local flightBases = flights[obj][id]
		table.sort(flightBases, function(a, b) return (a.count - #a.queue) < (b.count - #b.queue) end)
		if flightBases[#flightBases].count - #flightBases[#flightBases].queue > 0 then
			return flightBases[#flightBases]
		end
	elseif #bases == 1 and flights[obj][id][1].count - #flights[obj][id][1].queue > 0 then
		return flights[obj][id][1]
	end
	return false
end

local function chooseFlightBase(obj, from, to)
	local str = keywords.capabilities.flight[obj]
	if stationInfo[from.id].capabilities[str] then
		local fBase = flights[obj][from.id]
		if fBase.count - #fBase.queue > 0 then
			return from.id, getBestBase(obj, from.id)
		end
	elseif stationInfo[to.id].capabilities[str] then
		local fBase = flights[obj][to.id]
		if fBase.count - #fBase.queue > 0 then
			return to.id, getBestBase(obj, to.id)
		end
	else
		local options = {}
		for i, info in ipairs(stationInfo) do
			if info.type == keywords.stations.flightOnly then
				for _, baseInfo in ipairs(flights[obj][i]) do
					if baseInfo.count - #baseInfo.queue > 0 then
						table.insert(options, {id = i, base = baseInfo, distance = getDistance(from.location, baseInfo.location)})
					end
				end
			end
		end
		table.sort(options, function(a,b) return a.distance < b.distance end)
		return options[1].id, options[1].base
	end
end

local function queueFlight(objectType, objectInfo, origin, destination)
	local flightStation, base = chooseFlightBase(objectType, origin, destination)
	local total = 0
	while objectInfo.count > 0 do
		if not base then break end
		local count = math.min(objectInfo.count, config.maxFlightQuantity[objectType])
		local newInfo = {count = count}
		newInfo.name, newInfo.damage = normalizeName(objectInfo)
		local route = flight.route(base, origin.location, destination.location, nil, newInfo.count, newInfo.name.." "..newInfo.damage)
		flightID = flightID + 1
		table.insert(base.queue, {id = flightID, route = route, origin = origin, destination = destination, objectInfo = newInfo})
		flightLookup[flightID] = base
		objectInfo.count = objectInfo.count - count
		total = total + count
		if base.count < #base.queue + 1 then
			--if the base we're using runs out of quadracoptors, use a different base.
			flightStation, base = chooseFlightBase(objectType, origin, destination)
		end
	end
	return total
end

local function fulfillRequestsFromSurplus()
	--this is how everything moves, inventory systems create surplus and request entries as necessary.
	for type, names in pairs(request) do
		if surplus[type] then
			for name, stationList in pairs(names) do
				if surplus[type][name] then
					--create request list for this item.
					local requesters = {limited = {}, infinite = {}}
					for id, list in pairs(stationList) do
						for _, info in ipairs(list) do
							if info.count == true then
								table.insert(requesters.infinite, {id = id, location = info.location, total = info.total})
							else
								table.insert(requesters.limited, {id = id, location = info.location, count = info.count})
							end
						end
					end
					table.sort(requesters.limited, function(a,b) return a.count < b.count end)
					--now match surpluses to requests.
					--create surplus list for this item.
					local surpluses = {}
					for id, list in pairs(surplus[type][name]) do
						for _, info in ipairs(list) do
							table.insert(surpluses, {id = id, location = info.location, count = info.count})
						end
					end
					table.sort(surpluses, function(a,b) return a.count < b.count end)
					for i, info in ipairs(surpluses) do
						while info.count > 0 do
							if #requesters.limited > 0 then
								local requestInfo = requesters.limited[1]
								local count = math.min(info.count, requestInfo.count)
								local total = queueFlight(type, {combinedName = name, count = count}, {id = info.id, location = info.location}, {id = requestInfo.id, location = requestInfo.location})
								info.count = info.count - total
								requestInfo.count = requestInfo.count - total
								if requestInfo.count == 0 then
									table.remove(requesters.limited, 1)
								end
							elseif #requesters.infinite > 0 then
								table.sort(requesters.infinite, function(a,b) return a.total < b.total end)
								local requestInfo = requesters.infinite[1]
								local count = math.min(info.count, requestInfo.count)
								local total = queueFlight(type, {combinedName = name, count = count}, {id = info.id, location = info.location}, {id = requestInfo.id, location = requestInfo.location})
								info.count = info.count - total
								requestInfo.total = requestInfo.total + total
							else
								--no more requesters.
								break
							end
						end
					end
				end
			end
		end
	end
end

local function storeSurplus()
	--to store surplus in inventory, we create matching requests at the inventory's intake interfaces.
	for objType, names in pairs(surplus) do
		for _name, stationList in pairs(names) do
			for id, list in pairs(stationList) do
				for _, info in ipairs(list) do
					if not info.flag then
						--select a storage facility and instruct it to request the objects.
						local highCount, stationID = 0, -1
						local name, damage = normalizeName({combinedName = _name})
						for inv, stoInfo in pairs(storage[objType]) do
							--pick the facility with the most of the item already in storage.
							if stoInfo[name][damage] > highCount then
								highCount = stoInfo[name][damage]
								stationID = inv
							end
						end
						if stationID == -1 then
							--no storage facility has any yet, so select the closest,
							local lowDistance = math.huge
							for i, staInfo in pairs(stationInfo) do
								if staInfo.type == keywords.stations.storage[objType] then
									for j, loc in ipairs(staInfo.locations) do
										if string.find(loc.capabilities, keywords.capabilities.accept[objType], 1, true) then
											local distance = getDistance(info.location, loc.location)
											if distance < lowDistance then
												lowDistance = distance
												stationID = i
											end
										end
									end
								end
							end
						end
						if stationID == -1 then
							--failure to find a storage facility
						else
							rednet.send(stationID, {type = "create_request", objectType = objType, objectInfo = {name = name, damage = damage, count = info.count}, baseCode = config.baseCode}, "lyq-base-inv")
							--flag this surplus as destined for storage, so we don't attempt to store it again.
							info.flag = true
						end
					end
				end
			end
		end
	end
end

local function fillRequests()
	--to fill request from inventory, we create matching surpluses at the inventory's output interfaces.
	for objType, names in pairs(request) do
		for _name, stationList in pairs(names) do
			for id, list in pairs(stationList) do
				for _, info in ipairs(list) do
					--select a storage facility and instruct it to surplus the objects.
					local total = 0
					while info.count == true or total < info.count do
						local lowCount, stationID = math.huge, -1
						local name, damage = normalizeName({combinedName = _name})
						for inv, stoInfo in pairs(storage[objType]) do
							--pick the facility with the lowest quantity of the item in storage.
							if stoInfo[name] then
								local objectCount = stoInfo[name][damage]
								if objectCount < lowCount and objectCount > 0 then
									lowCount = objectCount
									stationID = inv
								end
							end
						end
						if info.count ~= true then
							lowCount = math.min(lowCount, info.count - total)
						else
							--build in a little safety for infinite consumers.
							lowCount = math.min(lowCount, 64)
						end
						if stationID == -1 then
							--failure to find a storage facility
							break
						else
							rednet.send(stationID, {type = "create_surplus", objectType = objType, objectInfo = {name = name, damage = damage, count = lowCount}, baseCode = config.baseCode}, "lyq-base-inv")
							total = total + lowCount
							--more infinite consumer safety
							if info.count == true then break end
						end
					end
				end
			end
		end
	end
end

while true do
	local event = {base.handleEvents(os.pullEventRaw())}
	if event[1] == "rednet_message" then
		local message = event[3]
		if event[4] == "lyq-base" and message.baseCode == config.baseCode then
			if message.type == "station_info" then
				local id = event[2]
				if not stationInfo[id] then
					stationInfo[id] = {
						locations = message.info,
						capabilities = {},
						type = message.stationType,
					}
				else
					stationInfo[id].locations = message.info
					stationInfo[id].capabilities = {}
					stationInfo[id].type = message.stationType
				end
				local info = stationInfo[id]
				for i, loc in ipairs (info.locations) do
					for match in string.gmatch(loc.capabilities, "(%S+)") do
						if not info.capabilities[match] then
							info.capabilities[match] = {loc.location}
						else
							table.insert(info.capabilities[match], loc.location)
						end
						if keywordLookup.capabilities.flight[match] then
							local objectType = keywordLookup.capabilities.flight[match]
							if not flights[objectType] then flights[objectType] = {} end
							if not flights[objectType][id] then flights[objectType][id] = {} end
							local found = false
							for j, info in ipairs(flights[objectType][id]) do
								if sameLocation(info.location, loc) then
									found = true
									break
								end
							end
							if not found then
								table.insert(flights[objectType][id], {location = loc, queue = {}, count = 0, delta = 0})
							end
						end
					end
				end
				--see if this station is a storage station, grab the list of contents if it is
				local storageKeyword = keywordLookup.station.storage[message.stationType]
				if storageKeyword == "item" then
					rednet.send(event[2], {type = "all_items_info", baseCode = config.baseCode},"lyq-base-inv")
				elseif storageKeyword == "fluid" then
					--fluids lookup
				end
				io.write("Station "..tostring(event[2]).." has capabilities: ")
				for label in pairs(info.capabilities) do
					io.write(label.." ")
				end
				io.write("\n")
			elseif message.type == "object_surplus" then
				--a station has too much of something.
				local objectName = resolveObjectName(message.objectType, message.objectInfo)
				if not surplus[message.objectType] then surplus[message.objectType] = {} end
				if not surplus[message.objectType][objectName] then surplus[message.objectType][objectName] = {} end
				if not surplus[message.objectType][objectName][event[2]] then surplus[message.objectType][objectName][event[2]] = {} end
				local list = surplus[message.objectType][objectName][event[2]]
				local found = false
				if #list > 0 then
					local loc = message.location
					for i = 1, #list do
						local listLoc = list[i].location
						if listLoc.x == loc.x and listLoc.y == loc.y and listLoc.z == loc.z then
							list[i].count = message.objectInfo.count
							found = true
							break
						end
					end
				end
				if not found then
					table.insert(surplus[message.objectType][objectName][event[2]], {location = message.location, count = message.objectInfo.count})
				end
			elseif message.type == "object_required" then
				--a station has too little of something.
				local objectName = resolveObjectName(message.objectType, message.objectInfo)
				if not request[message.objectType] then request[message.objectType] = {} end
				if not request[message.objectType][objectName] then request[message.objectType][objectName] = {} end
				if not request[message.objectType][objectName][event[2]] then request[message.objectType][objectName][event[2]] = {} end
				local list = request[message.objectType][objectName][event[2]]
				local found = false
				if #list > 0 then
					local loc = message.location
					for i = 1, #list do
						local listLoc = list[i].location
						if listLoc.x == loc.x and listLoc.y == loc.y and listLoc.z == loc.z then
							list[i].count = message.objectInfo.count
							found = true
							break
						end
					end
				end
				if not found then
					table.insert(request[message.objectType][objectName][event[2]], {location = message.location, count = message.objectInfo.count})
				end
				if list.count == true and not list.total then
					list.total = 0
				end
			elseif message.type == "flight_dispatched" then
				local baseInfo = flightLookup.id
				if baseInfo then
					baseInfo.count = baseInfo.count - 1
				end
			elseif message.type == "flight_arrived" then
				local loc = message.location
				for type, ids in pairs(flights) do
					for id, bases in pairs(ids) do
						for i, info in ipairs(bases) do
							if areLocationsEqual(info.location, loc) then
								info.count = info.count + 1
							end
						end
					end
				end
			end
		elseif event[4] == "lyq-base-inv" and message.baseCode == config.baseCode then
			if message.type == "all_items_info" then
				storage.item[event[2]] = message.info
			end
		end
	elseif event[1] == "terminate" then
		io.write("Stopping\n")
		return
	end
end
