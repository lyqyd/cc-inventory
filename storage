--storage api

local config = {
	databasePath = "storagedata",
	layers = 0,
	rows = 0,
	columns = 0,
	storageBlocks = {
		{
			name = "minecraft:chest",
			slots = 27,
			slotSize = 64,
		}
	},
	facing = 1,
	layout = {},
}

local storageDatabase = {}

--item lookup table, indexed by item name. Contains a table of tube ID, layer #, chest # triplets of which storage chests the item can be found in.
local itemLookup = {}

--item database table, intended to be fetched from master station.  Indexed by item name, contains general information about that item, like max stack size, as well as the ways the system can produce that item (crafting, etc.)
local itemDatabase = {}

--item processing queue, these are routes to fly, along with transaction IDs.
local processingQueue = {}

--item movement transactions, to allow read/write to occur all at once when the quad is dispatched.
local openTransactions = {}

local direction = {
	--facing north
	{"north", "east", "south", "west"},
	--facing east
	{"east", "south", "west", "north"},
	--facing south
	{"south", "west", "north", "east"},
	--facing west
	{"west", "north", "east", "south"},
}

local directions = {
	x = {
		{[1] = "east", [-1] = "west"},
		{[1] = "south", [-1] = "north"},
		{[1] = "west", [-1] = "east"},
		{[1] = "north", [-1] = "south"},
	},
	y = {
		[1] = "up",
		[-1] = "down",
	},
	z = {
		{[1] = "south", [-1] = "north"},
		{[1] = "west", [-1] = "east"},
		{[1] = "north", [-1] = "south"},
		{[1] = "east", [-1] = "west"},
	},
}

local flightLevels = {
	north = 92,
	east = 93,
	south = 93,
	west = 92,
}

local baseRotations = {
	{1, 2, 3, 4},
	{4, 1, 2, 3},
	{3, 4, 1, 2},
	{2, 3, 4, 1},
}

local transformVec = {
	{vector.new(-2, 0, 1), vector.new(-2, 0, -1)},
	{vector.new(1, 0, 2), vector.new(-1, 0, 2)},
	{vector.new(2, 0, -1), vector.new(2, 0, 1)},
	{vector.new(-1, 0, -2), vector.new(1, 0, -2)},
}

local storageInfo = {}
for i, info in ipairs(config.storageBlocks) do
	storageInfo[info.name] = info
end

local function prepareDatabase() 
	--initial fill of storageDatabase dimensions
	for i = 1, config.layers do
		storageDatabase[i] = {}
		for j = 1, config.rows do
			storageDatabase[i][j] = {}
			for k = 1, config.columns do
				storageDatabase[i][j][k] = {storage = "none", slotSize = 0, slotCount = 1, {name = "empty", count = 0}}
			end
		end
	end
end

--load storage database from disk.
local function readStorageDatabase()
	local handle = io.open(config.databasePath, "r")
	if handle then
		for line in handle:lines() do
			if string.match(line, "^%d+,%d+,%d+;%d+ .*") then
				local layer, row, column, count, name = string.match(line, "^(%d+),(%d+),(%d+);(%d+) (.*)")
				if layer and row and column and count and name then
					storageDatabase[tonumber(layer)][tonumber(row)][tonumber(column)] = {storage = config.storageBlocks[1].name, slotSize = config.storageBlocks[1].slotSize, slotCount = config.storageBlocks[1].slots, {name = name, count = tonumber(count)}}
				end
			elseif string.match(line, "^%d+,%d+,%d+;[%a%d%-]+:?[%a%d%-%^]+ ") then
				local layer, row, column, storageName, contents = string.match(line, "^(%d+),(%d+),(%d+);([%a%d%-]+:?[%a%d%-%^]+) (.*)")
				if storageName ~= "none" then
					local stored = {storage = storageName, slotSize = storageInfo[storageName].slotSize, slotCount = storageInfo[storageName].slots}
					for item, quantity in string.gmatch(contents, "([%a%d%-]+:?[%a%d%-%^]+),(%d+);") do
						table.insert(stored, {name = item, count = tonumber(quantity)})
					end
					storageDatabase[tonumber(layer)][tonumber(row)][tonumber(column)] = stored
				end
			end
		end
		handle:close()
	end
end

local function writeStorageDatabase()
	local handle = io.open(config.databasePath, "w")
	if handle then
		for i = 1, #storageDatabase do
			for j = 1, #storageDatabase[i] do
				for k = 1, #storageDatabase[i][j] do
					local entry = storageDatabase[i][j][k]
					local str = tostring(i)..","..tostring(j)..","..tostring(k)..";"..tostring(entry.storage).." "
					for i, info in ipairs(entry) do
						str = str..tostring(info.name)..","..tostring(info.count)..";"
					end
					if #entry == 0 then str = str.."empty,0;" end
					--trim excess empty slot designations from ends of lines.
					while string.match(str, ";empty,0;$") do
						str = string.match(str, "(.*;)empty,0;")
					end
					handle:write(str.."\n")
				end
			end
		end
		handle:close()
	end
end

local function prepareLookupTable()
	--assumes completely loaded and up to date storageDatabase.
	for i = 1, #storageDatabase do
		for j = 1, #storageDatabase[i] do
			for k = 1, #storageDatabase[i][j] do
				for slot = 1, #storageDatabase[i][j][k] do
					if not itemLookup[storageDatabase[i][j][k][slot].name] then
						itemLookup[storageDatabase[i][j][k][slot].name] = {}
					end
					table.insert(itemLookup[storageDatabase[i][j][k][slot].name], {i, j, k, slot})
				end
			end
		end
	end
end

function initialize(configuration)
	for k, v in pairs(configuration) do
		if config[k] then
			config[k] = v
		end
	end
	prepareDatabase()
	readStorageDatabase()
	writeStorageDatabase()
	prepareLookupTable()
end

function transaction(layer, row, column, slot, name, delta)
	storageDatabase[layer][row][column][slot].count = storageDatabase[layer][row][column][slot].count + delta
	if storageDatabase[layer][row][column][slot].count > 0 then
		storageDatabase[layer][row][column][slot].name = name
	else
		storageDatabase[layer][row][column][slot].name = "empty"
	end
	writeStorageDatabase()
end

function addLayers(storageBlock, count)
	local found = false
	for i = 1, #config.storageBlocks do
		if config.storageBlocks[i] == storageBlock then
			found = true
			break
		end
	end
	if count > 0 and found then
		for i = #storageDatabase, #storageDatabase + count do
			storageDatabase[i] = {}
			for j = 1, config.rows do
				storageDatabase[i][j] = {}
				for k = 1, config.columns do
					storageDatabase[i][j][k] = {storage = storageBlock, slotSize = storageInfo[storageBlock].slotSize, slotCount = storageInfo[storageBlock].slots, {name = "empty", count = 0}}
				end
			end
		end
		return true
	end
	return false
end


local function horizontalDistance(a, b)
	return math.sqrt((b.x - a.x)^2 + (b.z - a.z)^2)
end

local function concatenate(a, b)
	--fast table concatenation, appends the numerically-indexed contents of b to a.
	local n = #a
	for i = 1, #b do
		a[n + i] = b[i]
	end
	return #a
end

local function getDirections(a, b)
	local xDir = b.x - a.x
	local xName = directions.x[config.facing][xDir / math.abs(xDir)]
	local zDir = b.z - a.z
	local zName = directions.z[config.facing][zDir / math.abs(zDir)]
	if math.abs(xDir) >= math.abs(zDir) then
		return xName, math.abs(xDir), zName, math.abs(zDir)
	else
		return zName, math.abs(zDir), xName, math.abs(xDir)
	end
end

local function pointToPoint(a, b, shortFirst)
	local route, n = {}, 0
	local info = {short = {total = 0}, long = {total = 0}}
	info.long.name, info.long.dist, info.short.name, info.short.dist = getDirections(a, b)
	if shortFirst then
		if info.short.dist > 0 then
			n = n + 1
			route[n] = info.short.name.." "..tostring(info.short.dist)
		end
	end
	if info.long.dist > 0 then
		n = n + 1
		route[n] = info.long.name.." "..tostring(info.long.dist)
	end
	if not shortFirst then
		if info.short.dist > 0 then
			n = n + 1
			route[n] = info.short.name.." "..tostring(info.short.dist)
		end
	end
	return route
end

local function moveToChest(start, chest, finish, action)
	local route, n = {}, 0
	local function getRowAndColumn(a, b)
		local xDir = b.x - a.x
		local xName = directions.x[config.facing][xDir / math.abs(xDir)]
		local zDir = b.z - a.z
		local zName = directions.z[config.facing][zDir / math.abs(zDir)]
		return xName, math.abs(xDir), zName, math.abs(zDir)
	end
	info = {row = {}}, column = {}}
	info.row.name, info.row.dist, info.column.name, info.column.dist = getRowAndColumn(start, chest)
	if info.row.dist > 0 then
		n = n + 1
		route[n] = info.row.name.." "..info.row.dist
	end
	n = n + 1
	route[n] = info.column.name.." "..info.column.dist
	n = n + 1
	route[n] = action
	info.row.name, info.row.dist, info.column.name, info.column.dist = getRowAndColumn(chest, finish)
	n = n + 1
	route[n] = info.column.name.." "..info.column.dist
	if info.row.dist > 0 then
		n = n + 1
		route[n] = info.row.name.." "..info.row.dist
	end
	return route
end

function createStorageRoute(layer, row, column, count)
	local main, store = {x = config.layout.main[1], z = config.layout.main[2]}, {x = config.layout.store[1], z = config.layout.store[2]}
	local start, finish = {x = config.layout.shafts[1][1], z = config.layout.shafts[1][2]}, {x = config.layout.shafts[2][1], z = config.layout.shafts[2][2]}
	local route = pointToPoint(main, store)
	local n = #route
	n = n + 1
	route[n] = "suck "..tostring(count)
	n = concatenate(route, pointToPoint(store, start)
	n = n + 1
	route[n] = "down "..tostring(layer + 5)
	n = concatenate(route, moveToChest(start, {x = row, z = column}, finish, "drop "..tostring(count)))
	n = n + 1
	route[n] = "up "..tostring(layer + 5)
	concatenate(route, pointToPoint(finish, main))
	return route
end

function createRetrievalRoute(layer, row, column, count, data)
	local main, retrieve = {x = config.layout.main[1], z = config.layout.main[2]}, {x = config.layout.retrieve[1], z = config.layout.retrieve[2]}
	local start, finish = {x = config.layout.shafts[1][1], z = config.layout.shafts[1][2]}, {x = config.layout.shafts[2][1], z = config.layout.shafts[2][2]}
	local route = pointToPoint(main, start)
	local n = #route
	n = n + 1
	route[n] = "filter "..tostring(data.name).." "..tostring(data.damage)
	n = n + 1
	route[n] = "down "..tostring(layer + 5)
	n = concatenate(route, moveToChest(start, {x = row, z = column}, finish, "suck "..tostring(count)))
	n = n + 1
	route[n] = "up"..tostring(layer + 5)
	n = concatenate(route, pointToPoint(finish, retrieve))
	n = n + 1
	route[n] = "drop "..tostring(count)
	concatenate(route, pointToPoint(retrieve, main))
	return route
end

function createIntakeRoute(side, layer, row, column, count)
	local base = {x = config.layout.bases[baseRotations[config.facing][side]][1], z = config.layout.bases[baseRotations[config.facing][side]][2]}
	local input = vector.new(base.x, 0, base.z) + transformVec[side][2]
	local start, finish = {x = config.layout.shafts[1][1], z = config.layout.shafts[1][2]}, {x = config.layout.shafts[2][1], z = config.layout.shafts[2][2]}
	local route = pointToPoint(base, input, true)
	local n = #route
	n = n + 1
	route[n] = "suck "..tostring(count)
	n = concatenate(route, pointToPoint(input, start))
	n = n + 1
	route[n] = "down "..tostring(layer + 5)
	n = concatenate(route, moveToChest(start, {x = row, z = column}, finish, "drop "..tostring(count)))
	n = n + 1
	route[n] = "up "..tostring(layer + 5)
	concatenate(route, pointToPoint(finish, base))
	return route
end

function createOutputRoute(side)
	local base = {x = config.layout.bases[baseRotations[config.facing][side]][1], z = config.layout.bases[baseRotations[config.facing][side]][2]}
	local retrieve = {x = config.layout.retrieve[1], z = config.layout.retrieve[2]}
	local out = vector.new(base.x, 0, base.z) + transformVec[side][2]
	local route = pointToPoint(base, retrieve)
	local n = #route
	n = n + 1
	route[n] = "suck"
	n = concatenate(route, pointToPoint(retrieve, out, true))
	n = n + 1
	route[n] = "drop"
	concatenate(route, pointToPoint(out, base))
	return route
end

local function copy(tab)
	local ret = {}
	for k, v in pairs(tab) do
		if type(v) == "table" then
			ret[k] = copy(v)
		else
			ret[k] = v
		end
	end
	return ret
end

function getItemsAt(layer, row, column)
	return copy(storageDatabase[layer][row][column])
end

local function getCompoundName(data)
	if itemDatabase[data.name] and itemDatabase[data.name].ignoreDamage then
		return data.name
	elseif data.damage and data.damage > 0 then
		return data.name.."-"..tostring(data.damage)
	else
		return data.name
	end
end

local function getStorageInfo(layer, row, column)
	for i = 1, #config.storageBlocks do
		if storageDatabase[layer][row][column].storage == config.storageBlocks[i].name then
			return copy(config.storageBlocks[i])
		end
	end
end

function store(itemData, side, queue)
	local name = getCompoundName(itemData)
	local count = itemData.count
	local route
	if itemLookup[name] then
		local slotList = {}
		local loclist = {}
		for k, v in ipairs(itemLookup[name]) do
			local store = storageDatabase[v[1]][v[2]][v[3]][v[4]]
			if store.name then
				--database agrees that this is here.
				local precedingEmpty = false
				for i = v[4], 1, -1 do
					if storageDatabase[v[1]][v[2]][v[3]][i].name == "empty" then
						precedingEmpty = true
						break
					end
				end
				if not precedingEmpty then
					--no empty slots prior to this slot in this chest, so it is reachable.
					if not itemDatabase[itemData.name] then
						itemDatabase[itemData.name] = {}
						itemDatabase[itemData.name].maxStackSize = 64
					end
					local maxStoredSize
					local storeInfo = getStorageInfo(v[1], v[2], v[3])
					if storeInfo then maxStoredSize = storeInfo.slotSize end
					if maxStoredSize and store.count < maxStoredSize then
						local newSlot = true
						--see if this chest is already in our list of slots
						for _, info in ipairs(slotList) do
							if info.location[1] == v[1] and info.location[2] == v[2] and info.location[3] == v[3] then
								--if so, then just add to the list of slots in that chest.
								newSlot = false
								info.space = info.space + (maxStoredSize - store.count)
								table.insert(info.slots, {v[4], maxStoredSize - store.count})
								table.sort(info.slots, function(a, b) return a[1] < b[1] end)
								break
							end
						end
						if newSlot then
							table.insert(slotList, {space = maxStoredSize - store.count, location = {v[1], v[2], v[3]}, slots = {{v[4], maxStoredSize - store.count}}})
						end
					end
				end
			end
		end
		table.sort(slotList, function(a, b) return a.space > b.space end)
		for i = 1, #slotList do
			local flightQuantity = 0
			local loc
			for j = 1, #slotList[i].slots do
				local moveQuantity = math.min(slotList[i].slots[j][2], count)
				loc = slotList[i].location
				storage.transaction(loc[1], loc[2], loc[3], slotList[i].slots[j][1], name, moveQuantity)
				flightQuantity = flightQuantity + moveQuantity
				count = count - moveQuantity
				if count == 0 then break end
			end
			route = createIntakeRoute(side, loc[1], loc[2], loc[3], flightQuantity)
			queue(route)
			if count == 0 then break end
		end
	end
	if count > 0 then
		--item wasn't yet in db, or existing slots didn't have enough room.  Allocate new slot/chest.
		for i = 1, #storageDatabase do
			for j = 1, #storageDatabase[i] do
				for k = 1, #storageDatabase[i][j] do
					local storeInfo = getStorageInfo(i, j, k)
					for slot = 1, storeInfo.slots or #storageDatabase[i][j][k] do
						if not storageDatabase[i][j][k][slot] then storageDatabase[i][j][k][slot] = {name = "empty", count = 0} end
						if storageDatabase[i][j][k][slot].name == "empty" then
							if not itemLookup[name] then
								itemLookup[name] = {}
							end
							table.insert(itemLookup[name], {i, j, k, slot})
							transaction(i, j, k, slot, name, count)
							route = createIntakeRoute(side, i, j, k, count)
							queue(route)
							count = 0
							break
						end
					end
					if count == 0 then break end
				end
				if count == 0 then break end
			end
			if count == 0 then break end
		end
	end
	if count > 0 then
		return false
	else
		return true
	end
end

function retrieve(itemData, queue)
	local name = getCompoundName(itemData)
	local count = itemData.count
	local route
	local storageInformation = {}
	local slots = {}
	local lookup = itemLookup[name]
	for i, info in ipairs(lookup) do
		if not storageInformation[info[1]] or not storageInformation[info[1]][info[2]] or not storageInformation[info[1]][info[2]][info[3]] then
			storageInformation[info[1]] = storageInformation[info[1]] or {}
			storageInformation[info[1]][info[2]] = storageInformation[info[1]][info[2]] or {}
			storageInformation[info[1]][info[2]][info[3]] = storageInformation[info[1]][info[2]][info[3]] or {}
			storageInformation[info[1]][info[2]][info[3]] = getStorageInfo(info[1], info[2], info[3])
		end
		local storeInfo = storageInformation[info[1]][info[2]][info[3]]
		slots[storeInfo.slotSize] = slots[storeInfo.slotSize] or {}
		table.insert(slots[storeInfo.slotSize], info)
	end

	local sortedSlots = {}
	for size, list in pairs(slots) do
		table.sort(list, function(a, b) return storageDatabase[a[1]][a[2]][a[3]][a[4]].count < storageDatabase[b[1]][b[2]][b[3]][b[4]].count end)
		table.insert(sortedSlots, {size = size, locations = list})
	end
	table.sort(sortedSlots, function(a, b) return a.size < b.size end)

	for i, info in ipairs(sortedSlots) do
		for j, l in ipairs(info.locations) do
			local x, y, z = l[1], l[2], l[3]
			local slots = getItemsAt(x, y, z)
			for s = 1, #slots do
				if storageDatabase[x][y][z][s] and storageDatabase[x][y][z][s].name == name then
					local moveQuantity = math.min(storageDatabase[x][y][z][s].count, count)
					transaction(x, y, z, s, name, moveQuantity * -1)
					route = createRetrievalRoute(x, y, z, moveQuantity, itemData)
					queue(route)
					count = count - moveQuantity
					if count == 0 then break end
				end
			end
			if count == 0 then break end
		end
		if count == 0 then break end
	end

	if count > 0 then
		return false, count
	else
		return true
	end
end

function getItemCount(name, damage)
	local itemName = getCompoundName({name = name, damage = damage})
	local count = 0
	for i = 1, #storageDatabase do
		for j = 1, #storageDatabase[i] do
			for k = 1, #storageDatabase[i][j] do
				for slot = 1, #storageDatabase[i][j][k] do
					local info = storageDatabase[i][j][k][slot]
					if info.name == itemName then
						count = count + 1
					end
				end
			end
		end
	end
	return count
end

function getAllItemCounts()
	local items = {}
	for i = 1, #storageDatabase do
		for j = 1, #storageDatabase[i] do
			for k = 1, #storageDatabase[i][j] do
				for slot = 1, #storageDatabase[i][j][k] do
					local info = storageDatabase[i][j][k][slot]
					local name = string.match(info.name, "([%a%d%-]+:?[%a%d%-]+)%^?")
					local damage = string.match(info.name, "%^(%d+)$")
					if damage then damage = tonumber(damage) else damage = 0 end
					if not items[info.name] then items[info.name] = {[damage] = 0} end
					items[info.name][damage] = items[info.name][damage] + info.count
				end
			end
		end
	end
	return items
end

function calculateItemDensity()
	local occupied, total = 0, 0
	for i, row in ipairs(storageDatabase) do
		for j, column in ipairs(row) do
			for k, chest in ipairs(column) do
				local slotSize = chest.slotSize
				for l = 1, chest.slotCount do
					local info = chest[l]
					if info and info.count > 0 then
						total = total + slotSize
						occupied = occupied + info.count
					end
				end
			end
		end
	end
	if total > 0 then
		return occupied / total
	else
		return 0
	end
end

function getSpaceRemaining()
	local space = 0
	for i, row in ipairs(storageDatabase) do
		for j, column in ipairs(row) do
			for k, chest in ipairs(column) do
				local slotSize = chest.slotSize
				for l = 1, chest.slotCount do
					if chest[l] then
						space = space + (slotSize - chest[l].count)
					else
						space = space + slotSize
					end
				end
			end
		end
	end
	return space
end

function getSlotsRemaining()
	local slots = 0
	for i, row in ipairs(storageDatabase) do
		for j, column in ipairs(row) do
			for k, chest in ipairs(column) do
				for l = 1, chest.slotCount do
					if not chest[l] or chest[l].count == 0 then
						slots = slots + 1
					end
				end
			end
		end
	end
	return slots
end

function getDatabase()
	return copy(storageDatabase)
end
