--base api
--used to interlink different components.

local unpack = unpack or table.unpack

local dnsTime, pingTime, pingWait = 2, 5, 7

local comm = {
	base = {
		master = -1,
		protocol = "lyq-base",
		online = "station_online",
		offline = "station_offline",
		code = "",
		keepAlive = -1,
		name = "base",
		search = -1,
		hosts = {},
		responses = 0,
	},
	sub = {
		master = -1,
		protocol = "",
		online = "",
		offline = "",
		keepAlive = -1,
		name = "",
		search = -1,
		hosts = {},
		responses = 0,
	},
	clients = {
		name = {},
		protocol = "",
		online = {},
		offline = {},
		keepAlive = -1,
		list = {},
		liveStatus = {},
		types = {},
	},
	station = {
		type = "",
		locations = {},
	},
}

local flyQueues = {
	
}

local function areLocationsEqual(a, b)
	return a.x == b.x and a.y == b.y and a.z == b.z
end

function getBaseMaster()
	if comm.base.master > -1 then
		return comm.base.master
	else
		return false
	end
end

function getServiceMaster()
	if comm.sub.master > -1 then
		return comm.sub.master
	else
		return false
	end
end

function getClientType(client)
	if #comm.clients.list > 0 then
		for i = 1, #comm.clients.list do
			if comm.clients.list[i] == client then
				return comm.clients.types[i]
			end
		end
		return false, "not a client"
	else
		return false, "no clients"
	end
end

function getClientByType(clientType)
	if #comm.clients.list > 0 then
		for i = 1, #comm.clients.list do
			if comm.clients.types[i] == clientType then
				return comm.clients.list[i]
			end
		end
		return false, "no clients of that type"
	else
		return false, "no clients"
	end
end

function sendToBaseMaster(message, protocol)
	local master = getBaseMaster()
	if master then
		rednet.send(master, message, protocol or comm.base.protocol)
		return true
	else
		return false
	end
end

function sendToServiceMaster(message, protocol)
	local master = getServiceMaster()
	if master then
		rednet.send(master, message, protocol or comm.sub.protocol)
		return true
	else
		return false
	end
end

local function searchForHosts(info)
	info.master = -1
	rednet.broadcast({sType = "lookup", sProtocol = info.protocol}, "dns")
	info.search = os.startTimer(dnsTime)
	info.hosts = {}
	info.responses = 0
end

local function searchTimerExpired(info)
	if #info.hosts < 1 then
		io.write("Please set up a "..info.name.." master!\n")
		searchForHosts(info)
	else
		for i = 1, #info.hosts do
			rednet.send(info.hosts[i], {type = "base_query", baseCode = comm.base.code}, info.protocol)
		end
	end
end

local function handleClientSide(info, event)
	if event[2] == info.master then
		if event[3].type == "master_online" then
			io.write("Connected to "..info.name.." master. ("..tostring(event[2])..")\n")
			if info == comm.base and #comm.station.type > 0 then
				--update station info at base master, if applicable.
				rednet.send(info.master, {type = "station_info", stationType = comm.station.type, info = comm.station.locations, baseCode = comm.base.code}, info.protocol)
			end
			info.keepAlive = os.startTimer(pingWait)
		elseif event[3].type == "master_offline" then
			io.write(string.upper(string.sub(info.name, 1, 1))..string.sub(info.name, 2).." master went offline.\n")
			searchForHosts(info)
		elseif event[3].type == "keepalive_ping" then
			rednet.send(info.master, {type = "keepalive_pong", baseCode = comm.base.code}, info.protocol)
			info.keepAlive = os.startTimer(pingWait)
		end
	elseif event[3].type == "base_response" then
		if event[3].baseCode == comm.base.code then
			info.master = event[2]
			io.write("Attempting to connect to "..info.name.." master. ("..tostring(info.master)..")\n")
			rednet.send(info.master, {type = info.online, baseCode = comm.base.code}, info.protocol)
			info.keepAlive = os.startTimer(pingWait)
		elseif info.master == -1 then
			info.responses = info.responses + 1
			if info.responses == #info.hosts then
				io.write("Please set up a "..info.name.." master for base code '"..comm.base.code.."'!\n")
				searchForHosts(info)
			end
		end
	end
end

local function handleFlightDispatching(event)
	if event[1] == "rednet_message" then
		if event[2] == comm.base.master then
			if event[3].type = "fly_route" then
				for i, info in ipairs(flyQueues) do
					if areLocationsEqual(info.location, event[3].location) then
						info.queue:add({route = event[3].route, location = event[3].location, id = event[3].id, origin = event[3].origin, destination = event[3].destination, objectInfo = event[3].objectInfo})
						break
					end
				end
			end
		end
	elseif event[1] == "quad_landed" then
		for i, info in ipairs(flyQueues) do
			if event[2] == info.queue.side then
				rednet.send(comm.base.master, {type = "flight_arrived", location = info.location})
				break
			end
		end
	else
		for i, info in ipairs(flyQueues) do
			local result = {info.queue:handleEvents(unpack(event))}
			if result[1] == "route_depart" then
				rednet.send(comm.base.master, {type = "flight_dispatched", result[2].id, result[2].location})
			end
		end
	end
end

function handleEvents(...)
	local event = {...}
	if event[1] == "rednet_message" then
		if event[4] == "dns" and event[3].sType == "lookup response" then
			if event[3].sProtocol == comm.base.protocol then
				table.insert(comm.base.hosts, event[2])
			elseif event[3].sProtocol == comm.sub.protocol then
				table.insert(comm.sub.hosts, event[2])
			end
		elseif event[4] == comm.base.protocol and comm.base.protocol ~= comm.clients.protocol then
			handleClientSide(comm.base, event)
			if #flyQueues > 0 then
				handleFlightDispatching(event)
			end
		elseif event[4] == comm.sub.protocol then
			handleClientSide(comm.sub, event)
		elseif event[4] == comm.clients.protocol then
			if event[3].type == "base_query" then
				rednet.send(event[2], {type = "base_response", baseCode = comm.base.code}, comm.clients.protocol)
			elseif event[3].baseCode == comm.base.code then
				if comm.clients.online[event[3].type] then
					local found = false
					for k, id in ipairs(comm.clients.list) do
						if event[2] == id then
							comm.clients.liveStatus[k] = true
							found = true
							break
						end
					end
					if not found then
						table.insert(comm.clients.list, event[2])
						table.insert(comm.clients.liveStatus, true)
						table.insert(comm.clients.types, event[3].type)
					end
					io.write(comm.clients.name[event[3].type].." "..tostring(event[2]).." online.\n")
					rednet.send(event[2], {type = "master_online", baseCode = comm.base.code}, comm.clients.protocol)
				elseif comm.clients.offline[event[3].type] then
					local clientType = ""
					for k, id in ipairs(comm.clients.list) do
						if event[2] == id then
							table.remove(comm.clients.list, k)
							table.remove(comm.clients.liveStatus, k)
							clientType = table.remove(comm.clients.types, k)
							break
						end
					end
					io.write(comm.clients.name[clientType].." "..tostring(event[2]).." offline.\n")
				elseif event[3].type == "keepalive_pong" then
					for k, id in ipairs(comm.clients.list) do
						if event[2] == id then
							comm.clients.liveStatus[k] = true
							break
						end
					end
				end
			end
		end
	elseif event[1] == "timer" then
		if event[2] == comm.base.keepAlive then
			if comm.base.master > -1 then
				io.write("Base master timed out.\n")
				searchForHosts(comm.base)
			end
		elseif event[2] == comm.sub.keepAlive then
			if comm.sub.master > -1 then
				io.write("Backend timed out.\n")
				searchForHosts(comm.sub)
			end
		elseif event[2] == comm.clients.keepAlive then
			for i = #comm.clients.list, 1, -1 do
				if comm.clients.liveStatus[i] == false then
					table.remove(comm.clients.liveStatus, i)
					table.remove(comm.clients.list, i)
					local clientType = table.remove(comm.clients.types, i)
					io.write(comm.clients.name[clientType].." "..tostring(comm.clients.list[i]).." timed out.\n")
				end
			end
			for i = 1, #comm.clients.list do
				rednet.send(comm.clients.list[i], {type = "keepalive_ping", baseCode = comm.base.code}, comm.clients.protocol)
				comm.clients.liveStatus[i] = false
			end
			comm.clients.keepAlive = os.startTimer(pingTime)
		elseif event[2] == comm.base.search then
			searchTimerExpired(comm.base)
		elseif event[2] == comm.sub.search then
			searchTimerExpired(comm.sub)
		end
	elseif event[1] == "terminate" then
		if comm.base.master > -1 then rednet.send(comm.base.master, {type = comm.base.offline, baseCode = comm.base.code}, comm.base.protocol) end
		if comm.sub.master > -1 then rednet.send(comm.sub.master, {type = comm.sub.offline, baseCode = comm.base.code}, comm.sub.protocol) end
		if comm.clients.protocol then
			rednet.unhost(comm.clients.protocol)
			for i = 1, #comm.clients.list do
				rednet.send(comm.clients.list[i], {type = "master_offline", baseCode = config.baseCode}, comm.clients.protocol)
			end
		end
	end
	return unpack(event)
end

function initialize(baseCode, stationInfo, subConfiguration, clientConfiguration, nobase)
	comm.base.code = baseCode
	if stationInfo then
		comm.station.type = stationInfo.type
		comm.station.locations = stationInfo.locations
	end
	if clientConfiguration then
		config = clientConfiguration
		comm.clients.protocol = config.protocol
		comm.clients.online = config.online
		comm.clients.offline = config.offline
		comm.clients.name = config.name
		if config.list then comm.clients.list = config.list end
		comm.clients.keepAlive = os.startTimer(pingTime)
		if os.getComputerLabel() then
			rednet.host(comm.clients.protocol, os.getComputerLabel())
		else
			error("You must label this computer first.", 0)
		end
	end
	if not nobase then
		io.write("Searching for base master...\n")
		searchForHosts(comm.base)
	end
	if subConfiguration then
		config = subConfiguration
		comm.sub.protocol = config.protocol
		comm.sub.online = config.online
		comm.sub.offline = config.offline
		comm.sub.name = config.name
		if config.master then
			comm.sub.hosts = {config.master}
			searchTimerExpired(comm.sub)
		else
			io.write("Searching for backend...\n")
			searchForHosts(comm.sub)
		end
	end
end

function addFlightBase(flightQueue, location)
	table.insert(flyQueues, {queue = flightQueue, location = location})
end
