--base api
--used to interlink different components.

local unpack = unpack or table.unpack

local dnsTime, pingTime, pingWait = 2, 5, 7

local comm = {
	base = {
		master = -1,
		protocol = "lyq-base",
		online = "station_online",
		offline = "station_offline",
		code = "",
		keepAlive = -1,
		name = "base",
		search = -1,
		hosts = {},
		responses = 0,
	},
	sub = {
		master = -1,
		protocol = "",
		online = "",
		offline = "",
		keepAlive = -1,
		name = "",
		search = -1,
		hosts = {},
		responses = 0,
	},
	clients = {
		name = {},
		protocol = "",
		online = {},
		offline = {},
		keepAlive = -1,
		list = {},
		liveStatus = {},
		types = {},
	},
	station = {
		type = "",
		locations = {},
	},
}

local flyQueues = {
	
}

expose = {comm = comm, flyQueues = flyQueues}

local function areLocationsEqual(a, b)
	return a.x == b.x and a.y == b.y and a.z == b.z
end

function getBaseMaster()
	if comm.base.master > -1 then
		return comm.base.master
	else
		return false
	end
end

function getServiceMaster()
	if comm.sub.master > -1 then
		return comm.sub.master
	else
		return false
	end
end

function getClientType(client)
	if #comm.clients.list > 0 then
		for i = 1, #comm.clients.list do
			if comm.clients.list[i] == client then
				return comm.clients.types[i]
			end
		end
		return false, "not a client"
	else
		return false, "no clients"
	end
end

function getClientByType(clientType)
	if #comm.clients.list > 0 then
		for i = 1, #comm.clients.list do
			if comm.clients.types[i] == clientType then
				return comm.clients.list[i]
			end
		end
		return false, "no clients of that type"
	else
		return false, "no clients"
	end
end

function sendToBaseMaster(message, protocol)
	local master = getBaseMaster()
	if master then
		message.baseCode = comm.base.code
		rednet.send(master, message, protocol or comm.base.protocol)
		return true
	else
		return false
	end
end

function sendToServiceMaster(message, protocol)
	local master = getServiceMaster()
	if master then
		message.baseCode = comm.base.code
		rednet.send(master, message, protocol or comm.sub.protocol)
		return true
	else
		return false
	end
end

local function searchForHosts(info)
	info.master = -1
	rednet.broadcast({sType = "lookup", sProtocol = info.protocol}, "dns")
	info.search = os.startTimer(dnsTime)
	info.hosts = {}
	info.responses = 0
end

local function searchTimerExpired(info)
	if #info.hosts < 1 then
		io.write("Please set up a "..info.name.." master!\n")
		searchForHosts(info)
	elseif info.master == -1 then
		info.search = os.startTimer(dnsTime)
		for i = 1, #info.hosts do
			rednet.send(info.hosts[i], {type = "base_query", baseCode = comm.base.code}, info.protocol)
		end
	end
end

local function handleClientSide(info, event)
	if event[2] == info.master then
		if event[3].type == "master_online" then
			io.write("Connected to "..info.name.." master. ("..tostring(event[2])..")\n")
			if info == comm.base and #comm.station.type > 0 then
				--update station info at base master, if applicable.
				rednet.send(info.master, {type = "station_info", stationType = comm.station.type, info = comm.station.locations, baseCode = comm.base.code}, info.protocol)
			end
			info.keepAlive = os.startTimer(pingWait)
		elseif event[3].type == "master_offline" then
			io.write(string.upper(string.sub(info.name, 1, 1))..string.sub(info.name, 2).." master went offline.\n")
			searchForHosts(info)
		elseif event[3].type == "keepalive_ping" then
			rednet.send(info.master, {type = "keepalive_pong", baseCode = comm.base.code}, info.protocol)
			info.keepAlive = os.startTimer(pingWait)
		end
	elseif event[3].type == "base_response" then
		if event[3].baseCode == comm.base.code then
			info.master = event[2]
			io.write("Attempting to connect to "..info.name.." master. ("..tostring(info.master)..")\n")
			rednet.send(info.master, {type = info.online, baseCode = comm.base.code}, info.protocol)
			info.keepAlive = os.startTimer(pingWait)
		elseif info.master == -1 then
			info.responses = info.responses + 1
			if info.responses == #info.hosts then
				io.write("Please set up a "..info.name.." master for base code '"..comm.base.code.."'!\n")
				searchForHosts(info)
			end
		end
	end
end

local function handleFlightDispatching(event)
	if event[1] == "rednet_message" and event[4] == comm.base.protocol then
		if event[2] == comm.base.master then
			if event[3].type == "fly_route" then
				for i, info in ipairs(flyQueues) do
					if info.location and areLocationsEqual(info.location, event[3].location) then
						info.queue:add({route = event[3].route, location = event[3].location, id = event[3].id})
						break
					end
				end
			elseif event[3].type == "master_online" then
				for i, info in ipairs(flyQueues) do
					if info.location then
						sendToBaseMaster({type = "flight_base_info", info = {count = peripheral.call(info.queue.side, "getQuadCount"), location = info.location}})
					end
				end
			end
		end
	elseif event[1] == "quad_landed" then
		for i, info in ipairs(flyQueues) do
			if event[2] == info.queue.side and info.location then
				sendToBaseMaster({type = "flight_arrived", location = info.location})
				break
			end
		end
	else
		for i, info in ipairs(flyQueues) do
			local result = {info.queue:handleEvents(unpack(event))}
			if result[1] == "route_depart" and info.location then
				sendToBaseMaster({type = "flight_dispatched", result[3].id, result[3].location})
			end
		end
	end
end

function handleEvents(...)
	local event = {...}
	if event[1] == "rednet_message" then
		if event[4] == "dns" and event[3].sType == "lookup response" then
			if event[3].sProtocol == comm.base.protocol then
				table.insert(comm.base.hosts, event[2])
			elseif event[3].sProtocol == comm.sub.protocol then
				table.insert(comm.sub.hosts, event[2])
			end
		elseif event[4] == comm.base.protocol and comm.base.protocol ~= comm.clients.protocol then
			handleClientSide(comm.base, event)
		elseif event[4] == comm.sub.protocol then
			handleClientSide(comm.sub, event)
		elseif event[4] == comm.clients.protocol then
			if event[3].type == "base_query" then
				rednet.send(event[2], {type = "base_response", baseCode = comm.base.code}, comm.clients.protocol)
			elseif event[3].baseCode == comm.base.code then
				if comm.clients.online[event[3].type] then
					local found = false
					for k, id in ipairs(comm.clients.list) do
						if event[2] == id then
							comm.clients.liveStatus[k] = true
							found = true
							break
						end
					end
					if not found then
						table.insert(comm.clients.list, event[2])
						table.insert(comm.clients.liveStatus, true)
						table.insert(comm.clients.types, event[3].type)
					end
					io.write(comm.clients.name[event[3].type].." "..tostring(event[2]).." online.\n")
					rednet.send(event[2], {type = "master_online", baseCode = comm.base.code}, comm.clients.protocol)
				elseif comm.clients.offline[event[3].type] then
					local clientType = ""
					for k, id in ipairs(comm.clients.list) do
						if event[2] == id then
							table.remove(comm.clients.list, k)
							table.remove(comm.clients.liveStatus, k)
							clientType = table.remove(comm.clients.types, k)
							break
						end
					end
					if #clientType > 0 then
						io.write(comm.clients.name[clientType].." "..tostring(event[2]).." offline.\n")
					else
						io.write("Client "..tostring(event[2]).." offline.\n")
					end
				elseif event[3].type == "keepalive_pong" then
					for k, id in ipairs(comm.clients.list) do
						if event[2] == id then
							comm.clients.liveStatus[k] = true
							break
						end
					end
				end
			end
		end
	elseif event[1] == "timer" then
		if event[2] == comm.base.keepAlive then
			if comm.base.master > -1 then
				io.write("Base master timed out.\n")
				searchForHosts(comm.base)
			else
				searchForHosts(comm.base)
			end
		elseif event[2] == comm.sub.keepAlive then
			if comm.sub.master > -1 then
				io.write("Backend timed out.\n")
				searchForHosts(comm.sub)
			else
				searchForHosts(comm.sub)
			end
		elseif event[2] == comm.clients.keepAlive then
			for i = #comm.clients.list, 1, -1 do
				if comm.clients.liveStatus[i] == false then
					table.remove(comm.clients.liveStatus, i)
					table.remove(comm.clients.list, i)
					local clientType = table.remove(comm.clients.types, i)
					io.write(comm.clients.name[clientType].." "..tostring(comm.clients.list[i]).." timed out.\n")
				end
			end
			for i = 1, #comm.clients.list do
				rednet.send(comm.clients.list[i], {type = "keepalive_ping", baseCode = comm.base.code}, comm.clients.protocol)
				comm.clients.liveStatus[i] = false
			end
			comm.clients.keepAlive = os.startTimer(pingTime)
		elseif event[2] == comm.base.search then
			searchTimerExpired(comm.base)
		elseif event[2] == comm.sub.search then
			searchTimerExpired(comm.sub)
		end
	elseif event[1] == "terminate" then
		if comm.base.master > -1 then rednet.send(comm.base.master, {type = comm.base.offline, baseCode = comm.base.code}, comm.base.protocol) end
		if comm.sub.master > -1 then rednet.send(comm.sub.master, {type = comm.sub.offline, baseCode = comm.base.code}, comm.sub.protocol) end
		if comm.clients.protocol then
			rednet.unhost(comm.clients.protocol)
			for i = 1, #comm.clients.list do
				rednet.send(comm.clients.list[i], {type = "master_offline", baseCode = config.baseCode}, comm.clients.protocol)
			end
		end
	end
	if #flyQueues > 0 then
		handleFlightDispatching(event)
	end
	return unpack(event)
end

function initialize(baseCode, stationInfo, subConfiguration, clientConfiguration, nobase)
	comm.base.code = baseCode
	if stationInfo then
		comm.station.type = stationInfo.type
		comm.station.locations = stationInfo.locations
	end
	if clientConfiguration then
		config = clientConfiguration
		comm.clients.protocol = config.protocol
		comm.clients.online = config.online
		comm.clients.offline = config.offline
		comm.clients.name = config.name
		if config.list then comm.clients.list = config.list end
		comm.clients.keepAlive = os.startTimer(pingTime)
		if os.getComputerLabel() then
			rednet.host(comm.clients.protocol, os.getComputerLabel())
		else
			error("You must label this computer first.", 0)
		end
	end
	if not nobase then
		io.write("Searching for base master...\n")
		searchForHosts(comm.base)
	end
	if subConfiguration then
		config = subConfiguration
		comm.sub.protocol = config.protocol
		comm.sub.online = config.online
		comm.sub.offline = config.offline
		comm.sub.name = config.name
		if config.master then
			comm.sub.hosts = {config.master}
			searchTimerExpired(comm.sub)
		else
			io.write("Searching for backend...\n")
			searchForHosts(comm.sub)
		end
	end
end

function addFlightBase(flightQueue, location)
	table.insert(flyQueues, {queue = flightQueue, location = location})
end

function setup(conf, location, face)
	while not os.getComputerLabel() do
		print("Please provide a label for this computer.")
		write("> ")
		local label = read()
		if #label >= 1 then
			os.setComputerLabel(label)
			break
		else
			print("A label is required!")
		end
	end
	while true do
		print("What is the name code for this base?")
		print("Base name codes are used to group and differentiate sites.")
		write("> ")
		local baseCode = read()
		if baseCode and #baseCode > 0 then
			conf.baseCode = baseCode
			break
		else
			print("A base name code is required!")
		end
	end
	if location then
		local loc = vector.new(gps.locate())
		if loc.y == 0 then
			local x, y, z
			repeat
				print("What is this station's X coordinate?")
				print("Use the location of this computer.")
				write("> ")
				x = tonumber(read())
				if not (x and x == math.floor(x)) then
					print("A valid integer is required!")
					x = nil
				end
			until x
			repeat
				print("What is this station's Y coordinate?")
				print("Use the location of this computer.")
				write("> ")
				y = tonumber(read())
				if not (y and y == math.floor(y) and y > 0) then
					print("A valid positive integer is required!")
					y = nil
				end
			until y
			repeat
				print("What is this station's Z coordinate?")
				print("Use the location of this computer.")
				write("> ")
				z = tonumber(read())
				if not (z and z == math.floor(z)) then
					print("A valid integer is required!")
					z = nil
				end
			until z
			loc = vector.new(x, y, z)
		end
		conf.location = loc
	end
	if face then
		while true do
			print("Which direction does this station face?")
			print(face)
			print("Enter 1 - 4, corresponding to the correct direction:")
			print("1. north      2. east")
			print("3. south      4. west")
			write("> ") 
			local direction = tonumber(read())
			if direction and direction == math.floor(direction) and direction >= 1 and direction <= 4 then
				conf.facing = direction
				break
			else
				print("A valid direction is required!")
			end
		end
	end
end
